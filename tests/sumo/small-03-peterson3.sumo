/* small-03-peterson3.sumo - Peterson's algorithm for 3 processes   */
/* generated by: m4 -DN=3 peterson.m4 > peterson3.prom              */

short mutex;
short turn0;
short turn1;
short turn2;

short flag0;
short flag1;
short flag2;

active proctype P0 () {
    short j;
    short k;
    do  
    ::  /* again */
        k = 0; /* count max N-1 rounds of competition */
        do
        ::  k < 3-1 ->
                flag0 = k;
                if
                :: k == 0 -> turn0 = 0;
                :: k == 1 -> turn1 = 0;
                :: k == 2 -> turn2 = 0;
                fi;
                
                j = 0; /* for all j != _pid */
                do
                ::  j == 0 -> j = j+1;
                ::  j != 0 -> 
                    if
                    ::  j < 3 ->
                            if
                            :: j == 0 && k == 0 -> flag0 < k || turn0 != 0; j = j+1;
                            :: j == 0 && k == 1 -> flag0 < k || turn1 != 0; j = j+1;
                            :: j == 0 && k == 2 -> flag0 < k || turn2 != 0; j = j+1;
                            :: j == 1 && k == 0 -> flag1 < k || turn0 != 0; j = j+1;
                            :: j == 1 && k == 1 -> flag1 < k || turn1 != 0; j = j+1;
                            :: j == 1 && k == 2 -> flag1 < k || turn2 != 0; j = j+1;
                            :: j == 2 && k == 0 -> flag2 < k || turn0 != 0; j = j+1;
                            :: j == 2 && k == 1 -> flag2 < k || turn1 != 0; j = j+1;
                            :: j == 2 && k == 2 -> flag2 < k || turn2 != 0; j = j+1;
                            fi;
                    ::  j >= 3 ->
                            break;
                    fi;
                od;
                k = k+1;
        ::  k >= 3-1 -> /* survived all N-1 rounds */
                break;
        od;
        
        mutex = mutex+1;
        assert(mutex == 1);
        mutex = mutex-1;

        flag0 = 0;
    od;
}

active proctype P1 () {
    short j;
    short k;
    do  
    ::  /* again */
        k = 0; /* count max N-1 rounds of competition */
        do
        ::  k < 3-1 ->
                flag1 = k;
                if
                :: k == 0 -> turn0 = 1;
                :: k == 1 -> turn1 = 1;
                :: k == 2 -> turn2 = 1;
                fi;
                
                j = 0; /* for all j != _pid */
                do
                ::  j == 1 -> j = j+1;
                ::  j != 1 -> 
                    if
                    ::  j < 3 ->
                            if
                            :: j == 0 && k == 0 -> flag0 < k || turn0 != 1; j = j+1;
                            :: j == 0 && k == 1 -> flag0 < k || turn1 != 1; j = j+1;
                            :: j == 0 && k == 2 -> flag0 < k || turn2 != 1; j = j+1;
                            :: j == 1 && k == 0 -> flag1 < k || turn0 != 1; j = j+1;
                            :: j == 1 && k == 1 -> flag1 < k || turn1 != 1; j = j+1;
                            :: j == 1 && k == 2 -> flag1 < k || turn2 != 1; j = j+1;
                            :: j == 2 && k == 0 -> flag2 < k || turn0 != 1; j = j+1;
                            :: j == 2 && k == 1 -> flag2 < k || turn1 != 1; j = j+1;
                            :: j == 2 && k == 2 -> flag2 < k || turn2 != 1; j = j+1;
                            fi;
                    ::  j >= 3 ->
                            break;
                    fi;
                od;
                k = k+1;
        ::  k >= 3-1 -> /* survived all N-1 rounds */
                break;
        od;
        
        mutex = mutex+1;
        assert(mutex == 1);
        mutex = mutex-1;

        flag1 = 0;
    od;
}

active proctype P2 () {
    short j;
    short k;
    do  
    ::  /* again */
        k = 0; /* count max N-1 rounds of competition */
        do
        ::  k < 3-1 ->
                flag2 = k;
                if
                :: k == 0 -> turn0 = 2;
                :: k == 1 -> turn1 = 2;
                :: k == 2 -> turn2 = 2;
                fi;
                
                j = 0; /* for all j != _pid */
                do
                ::  j == 2 -> j = j+1;
                ::  j != 2 -> 
                    if
                    ::  j < 3 ->
                            if
                            :: j == 0 && k == 0 -> flag0 < k || turn0 != 2; j = j+1;
                            :: j == 0 && k == 1 -> flag0 < k || turn1 != 2; j = j+1;
                            :: j == 0 && k == 2 -> flag0 < k || turn2 != 2; j = j+1;
                            :: j == 1 && k == 0 -> flag1 < k || turn0 != 2; j = j+1;
                            :: j == 1 && k == 1 -> flag1 < k || turn1 != 2; j = j+1;
                            :: j == 1 && k == 2 -> flag1 < k || turn2 != 2; j = j+1;
                            :: j == 2 && k == 0 -> flag2 < k || turn0 != 2; j = j+1;
                            :: j == 2 && k == 1 -> flag2 < k || turn1 != 2; j = j+1;
                            :: j == 2 && k == 2 -> flag2 < k || turn2 != 2; j = j+1;
                            fi;
                    ::  j >= 3 ->
                            break;
                    fi;
                od;
                k = k+1;
        ::  k >= 3-1 -> /* survived all N-1 rounds */
                break;
        od;
        
        mutex = mutex+1;
        assert(mutex == 1);
        mutex = mutex-1;

        flag2 = 0;
    od;
}



